{"version":3,"sources":["../../src/layer.js"],"names":[],"mappings":"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","file":"layer.js","sourcesContent":["import kotoAssert from './assert.js';\n\n\n/**\n * Create a layer using the provided `base`. The layer instance is *not*\n * exposed to d3.chart users. Instead, its instance methods are mixed in to the\n * `base` selection it describes; users interact with the instance via these\n * bound methods.\n *\n * @private\n * @class\n *\n * @param {d3.selection} base The containing DOM node for the layer.\n */\nclass Layer {\n  constructor(base, options) {\n    this._base = base;\n    this._handlers = {};\n    this._lifecycleRe = /^(enter|update|merge|exit)(:transition)?$/;\n\n    if (options) {\n      // Set layer methods (required)\n      this.dataBind = options.dataBind;\n      this.insert = options.insert;\n\n      // Bind events (optional)\n      if ('events' in options) {\n        for (var eventName in options.events) {\n          this.on(eventName, options.events[eventName]);\n        }\n      }\n    }\n  }\n\n  /**\n   * Invoked by {@link Layer#draw} to join data with this layer's DOM nodes. This\n   * implementation is \"virtual\"--it *must* be overridden by Layer instances.\n   *\n   * @param {Array} data Value passed to {@link Layer#draw}\n   */\n  dataBind() {\n    kotoAssert(false, 'Layers must specify a dataBind method.');\n  }\n\n  /**\n   * Invoked by {@link Layer#draw} in order to insert new DOM nodes into this\n   * layer's `base`. This implementation is \"virtual\"--it *must* be overridden by\n   * Layer instances.\n   */\n  insert() {\n    kotoAssert(false, 'Layers must specify an `insert` method.');\n  }\n\n  /**\n   * Subscribe a handler to a \"lifecycle event\". These events (and only these\n   * events) are triggered when {@link Layer#draw} is invoked--see that method\n   * for more details on lifecycle events.\n   *\n   * @param {String} eventName Identifier for the lifecycle event for which to\n   *        subscribe.\n   * @param {Function} handler Callback function\n   *\n   * @returns {Chart} Reference to the layer instance (chaining).\n   */\n  on(eventName, handler, options) {\n    options = options || {};\n\n    kotoAssert(this._lifecycleRe.test(eventName),\n      `Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n\n    if (!(eventName in this._handlers)) {\n      this._handlers[eventName] = [];\n    }\n    this._handlers[eventName].push({\n      callback: handler,\n      chart: options.chart || null\n    });\n\n    return this;\n  }\n\n  /**\n   * Unsubscribe the specified handler from the specified event. If no handler is\n   * supplied, remove *all* handlers from the event.\n   *\n   * @param {String} eventName Identifier for event from which to remove\n   *        unsubscribe\n   * @param {Function} handler Callback to remove from the specified event\n   *\n   * @returns {Chart} Reference to the layer instance (chaining).\n   */\n  off(eventName, handler) {\n    var handlers = this._handlers[eventName];\n    var idx;\n\n    kotoAssert(this._lifecycleRe.test(eventName),\n      `Unrecognized lifecycle event name specified to 'Layer#on': '${eventName}'.`);\n\n    if (!handlers) {\n      return this;\n    }\n\n    if (arguments.length === 1) {\n      handlers.length = 0;\n      return this;\n    }\n\n    for (idx = handlers.length - 1; idx > -1; --idx) {\n      if (handlers[idx].callback === handler) {\n        handlers.splice(idx, 1);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Render the layer according to the input data: Bind the data to the layer\n   * (according to {@link Layer#dataBind}, insert new elements (according to\n   * {@link Layer#insert}, make lifecycle selections, and invoke all relevant\n   * handlers (as attached via {@link Layer#on}) with the lifecycle selections.\n   *\n   * - update\n   * - update:transition\n   * - enter\n   * - enter:transition\n   * - exit\n   * - exit:transition\n   *\n   * @param {Array} data Data to drive the rendering.\n   */\n  draw(data) {\n    var bound,\n      entering,\n      events,\n      selection,\n      method,\n      handlers,\n      eventName,\n      idx,\n      len,\n      tidx,\n      tlen,\n      promises = [];\n\n    function endall(transition, callback) {\n      var n = 0;\n      if (transition.size() === 0) {\n        callback();\n      } else {\n        transition\n          .each(function() {\n            ++n;\n          })\n          .each('interrupt.promise', function () {\n            callback.apply(this, arguments);\n          })\n          .each('end.promise', function () {\n            if (!--n) {\n              callback.apply(this, arguments);\n            }\n          });\n      }\n    }\n\n    function promiseCallback (resolve) {\n      selection.call(endall, function() {\n        resolve(true);\n      });\n    }\n\n    bound = this.dataBind.call(this._base, data);\n\n    kotoAssert(bound instanceof d3.selection,\n      'Invalid selection defined by `Layer#dataBind` method.');\n    kotoAssert(bound.enter, 'Layer selection not properly bound.');\n\n    entering = bound.enter();\n    entering._chart = this._base._chart;\n\n    events = [\n      {\n        name: 'update',\n        selection: bound\n      },\n      {\n        name: 'enter',\n        selection: entering,\n        method: this.insert\n      },\n      {\n        name: 'merge',\n        // Although the `merge` lifecycle event shares its selection object\n        // with the `update` lifecycle event, the object's contents will be\n        // modified when d3.chart invokes the user-supplied `insert` method\n        // when triggering the `enter` event.\n        selection: bound\n      },\n      {\n        name: 'exit',\n        // Although the `exit` lifecycle event shares its selection object\n        // with the `update` and `merge` lifecycle events, the object's\n        // contents will be modified when d3.chart invokes\n        // `d3.selection.exit`.\n        selection: bound,\n        method: bound.exit\n      }\n    ];\n\n    for (var i = 0, l = events.length; i < l; ++i) {\n      eventName = events[i].name;\n      selection = events[i].selection;\n      method = events[i].method;\n\n      // Some lifecycle selections modify shared state, so they must be\n      // deferred until just prior to handler invocation.\n      if (typeof method === 'function') {\n        selection = method.call(selection);\n      }\n\n      if (selection.empty()) {\n        continue;\n      }\n\n      // Although `selection instanceof d3.selection` is more explicit,\n      // it fails in IE8, so we use duck typing to maintain\n      // compatability.\n\n      kotoAssert(selection && selection instanceof d3.selection,\n        `Invalid selection defined for ${eventName} lifecycle event.`);\n\n      handlers = this._handlers[eventName];\n\n      if (handlers) {\n        for (idx = 0, len = handlers.length; idx < len; ++idx) {\n          // Attach a reference to the parent chart so the selection\"s\n          // `chart` method will function correctly.\n          selection._chart = handlers[idx].chart || this._base._chart;\n          selection.call(handlers[idx].callback);\n        }\n      }\n\n      handlers = this._handlers[eventName + ':transition'];\n\n      if (handlers && handlers.length) {\n        selection = selection.transition();\n        for (tlen = handlers.length, tidx = 0; tidx < tlen; ++tidx) {\n          selection._chart = handlers[tidx].chart || this._base._chart;\n          selection.call(handlers[tidx].callback);\n          promises.push(new Promise(promiseCallback));\n        }\n      }\n      this.promise = Promise.all(promises);\n    }\n  }\n}\n\nexport default Layer;\n"]}